<!doctype html>
<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width,initial-scale=1'>
<title>MR Flashing v5.4</title>
<link rel='manifest' href='manifest.json'><meta name='theme-color' content='#0b5fff'>
<style>
body{margin:0;font-family:-apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial}
header{padding:10px 12px;border-bottom:1px solid #ddd}
canvas{border:1px solid #999;touch-action:none;max-width:100%;background:#fff}
.panel{display:flex;gap:8px;flex-wrap:wrap;padding:10px;border-bottom:1px solid #eee}
label{display:flex;flex-direction:column;font-size:12px}
input,select,button{padding:8px;border:1px solid #ccc;border-radius:6px;background:#fff}
.pill{background:#f3f3f3;border:1px solid #ddd;border-radius:999px;padding:2px 6px}
.gridbg{background:
  linear-gradient(0deg, rgba(0,0,0,.06) 1px, transparent 1px),
  linear-gradient(90deg, rgba(0,0,0,.06) 1px, transparent 1px);
  background-size:24px 24px;}
.inline-input{position:absolute; z-index:10; transform:translate(-50%,-50%);}
.inline-input input{padding:6px 8px;font-size:14px;border:2px solid #d00;border-radius:8px;min-width:90px;text-align:center}
.badge{background:#d00;color:#fff;border-radius:12px;padding:2px 6px;font-size:12px}
</style></head>
<body>
<header><strong>MR Flashing v5.4</strong></header>

<div class='panel'>
  <label>Zoom <input id='zoom' type='range' min='0.5' max='3' step='0.1' value='1'></label>
  <label>Scale(px/mm) <input id='scale' type='number' step='0.1' value='1'></label>
  <label>Snap(px) <input id='snap' type='number' value='6'></label>
  <label>Face <select id='face'><option value='left'>Left</option><option value='right'>Right</option></select></label>
  <label>Colourbond <select id='colour'><option value='#ECEBE6'>Surfmist</option><option value='#2B2B2B'>Monument</option><option value='#4B4F46'>Woodland Grey</option></select></label>
  <button id='lock'>ðŸ”’ Lock</button><button id='undo'>Undo</button><button id='redo'>Redo</button>
  <span class='pill'>Tap to draw â€¢ Doubleâ€‘tap to finish â€¢ When ðŸ”’ tap a length or corner angle â†’ type â†’ Enter</span>
</div>

<div style='padding:10px; position:relative'>
  <canvas id='cv' class='gridbg' width='980' height='560'></canvas>
  <div id='overlay'></div>
</div>

<div class='panel'>
  <label>Seg #<input id='seg' type='number' value='0' min='0'></label>
  <label>Length (mm)<input id='segLen' type='number' value='0'></label>
  <label>Angle (Â°)<input id='segAng' type='number' value='0'></label>
  <button id='apply'>Apply segment</button>
  <div style='width:24px'></div>
  <label>Corner #<input id='corner' type='number' value='1' min='1'></label>
  <label>Corner Angle (Â°)<input id='cornerAng' type='number' value='90' step='0.1'></label>
  <button id='applyCorner'>Apply corner</button>
</div>

<script>
const cv=document.getElementById('cv'),ctx=cv.getContext('2d');
let Z=1, pxPerMm=1, snap=6; let locked=false;
document.getElementById('zoom').oninput=e=>{Z=parseFloat(e.target.value||'1');draw()};
document.getElementById('scale').onchange=e=>{pxPerMm=parseFloat(e.target.value||'1');draw()};
document.getElementById('snap').onchange=e=>{snap=parseInt(e.target.value||'0')};
document.getElementById('lock').onclick=()=>{locked=!locked;document.getElementById('lock').textContent=locked?'ðŸ”“ Unlock':'ðŸ”’ Lock'};
const faceSel=document.getElementById('face'), colourSel=document.getElementById('colour');

let path=[], drawing=false, history=[], redo=[]; let lastTap=0;
function push(){history.push(JSON.stringify(path));if(history.length>200)history.shift();redo.length=0;}
function undo(){if(history.length){redo.push(JSON.stringify(path));path=JSON.parse(history.pop());draw();}}
function redoF(){if(redo.length){history.push(JSON.stringify(path));path=JSON.parse(redo.pop());draw();}}
document.getElementById('undo').onclick=undo; document.getElementById('redo').onclick=redoF;

function pos(e){const r=cv.getBoundingClientRect();const x=((e.touches?e.touches[0].clientX:e.clientX)-r.left)/Z;const y=((e.touches?e.touches[0].clientY:e.clientY)-r.top)/Z;return {x,y};}
function snapP(p){if(!snap)return p;return {x:Math.round(p.x*snap)/snap,y:Math.round(p.y*snap)/snap};}

function down(e){
  const p=pos(e); const now=Date.now();
  if(locked){ pickAtScreen({x:p.x*Z,y:p.y*Z}); e.preventDefault(); return; }
  if(now-lastTap<300){drawing=false;} lastTap=now;
  const sp=snapP(p);
  if(!drawing){push(); path=[sp]; drawing=true;} else {push(); path.push(sp);}
  draw(); e.preventDefault();
}
function move(e){ if(!drawing||!path.length||locked) return; path[path.length-1]=snapP(pos(e)); draw(); e.preventDefault(); }
function up(e){ e.preventDefault(); }

cv.addEventListener('pointerdown',down,{passive:false}); cv.addEventListener('pointermove',move,{passive:false}); cv.addEventListener('pointerup',up,{passive:false});
cv.addEventListener('touchstart',down,{passive:false}); cv.addEventListener('touchmove',move,{passive:false}); cv.addEventListener('touchend',up,{passive:false});
cv.addEventListener('mousedown',down); cv.addEventListener('mousemove',move); ['mouseup','mouseleave'].forEach(ev=>cv.addEventListener(ev,up));

function segs(){const s=[]; for(let i=0;i<path.length-1;i++) s.push([path[i],path[i+1],i]); return s;}
function norm180(a){a=((a%360)+360)%360; return a>180?360-a:a;} // 0..180
function normal(ax,ay,bx,by){const dx=bx-ax,dy=by-ay; const L=Math.hypot(dx,dy)||1; return {x:-dy/L,y:dx/L};}

const overlay=document.getElementById('overlay');
function clearInline(){ overlay.innerHTML=''; }
function showInline(screenX, screenY, value, onEnter){
  clearInline();
  const wrap=document.createElement('div'); wrap.className='inline-input'; wrap.style.left=screenX+'px'; wrap.style.top=screenY+'px';
  const input=document.createElement('input'); input.value=value; wrap.appendChild(input);
  overlay.appendChild(wrap); input.focus(); input.select();
  input.addEventListener('keydown', (ev)=>{
    if(ev.key==='Enter'){ onEnter(parseFloat(input.value)); clearInline(); draw(); }
    if(ev.key==='Escape'){ clearInline(); draw(); }
  });
}

function pickAtScreen(sp){
  // pick nearest among: segment badges midpoints and corner chips
  let bestKind=null,bestIndex=-1, bestd=1e9, bestPt=null;
  // segments
  segs().forEach(([a,b,i])=>{
    const midx=(a.x+b.x)/2*Z, midy=(a.y+b.y)/2*Z;
    const d=Math.hypot(sp.x-midx, sp.y-midy);
    if(d<bestd){bestd=d;bestKind='seg';bestIndex=i;bestPt={x:midx,y=midy};}
  });
  // corners
  for(let i=1;i<path.length-1;i++){
    const p=path[i]; const bx=p.x*Z+8, by=p.y*Z-8;
    const d=Math.hypot(sp.x-bx, sp.y-by);
    if(d<bestd){bestd=d;bestKind='corner';bestIndex=i;bestPt={x:bx,y:by};}
  }
  if(bestd<40){
    if(bestKind==='seg'){
      const a=path[bestIndex], b=path[bestIndex+1];
      const dx=b.x-a.x, dy=b.y-a.y;
      const lengthMm=(Math.hypot(dx,dy)/pxPerMm);
      showInline(bestPt.x, bestPt.y, Math.round(lengthMm), (newLen)=>{
        const ang=Math.atan2(-dy, dx); // convert to our standard
        const L=(newLen||0)*pxPerMm;
        path[bestIndex+1]={x:a.x+L*Math.cos(ang), y:a.y-L*Math.sin(ang)};
      });
    }else{
      const current=cornerAngle(path[bestIndex-1],path[bestIndex],path[bestIndex+1]);
      showInline(bestPt.x, bestPt.y, current.toFixed(1), (newAng)=>{
        applyCorner(bestIndex, parseFloat(newAng||current));
      });
    }
  }
}

function cornerAngle(prev,pt,next){
  const v1={x:prev.x-pt.x,y:prev.y-pt.y}, v2={x:next.x-pt.x,y:next.y-pt.y};
  const dot=v1.x*v2.x+v1.y*v2.y, l1=Math.hypot(v1.x,v1.y), l2=Math.hypot(v2.x,v2.y);
  if(l1*l2===0) return 0;
  let ang = Math.acos(Math.max(-1,Math.min(1,dot/(l1*l2)))); // radians
  return +(Math.min(ang*180/Math.PI,180)).toFixed(1);
}

function applyCorner(i, desiredDeg){
  if(path.length<3) return;
  i=Math.max(1, Math.min(i, path.length-2));
  const desired=Math.max(0, Math.min(180, desiredDeg)) * Math.PI/180;

  const Pm=path[i-1], P=path[i], Pn=path[i+1];
  const vPrev={x:P.x-Pm.x, y:P.y-Pm.y};
  const thetaPrev=Math.atan2(vPrev.y, vPrev.x);
  const delta = Math.PI - desired; // turn angle

  // choose sign that keeps smaller arc (both are small here); pick one closest to current
  const cur=Math.atan2(Pn.y-P.y, Pn.x-P.x);
  const opt1=thetaPrev + delta, opt2=thetaPrev - delta;
  const d1=Math.abs(Math.atan2(Math.sin(cur-opt1), Math.cos(cur-opt1)));
  const d2=Math.abs(Math.atan2(Math.sin(cur-opt2), Math.cos(cur-opt2)));
  const theta = d1<=d2? opt1 : opt2;

  const L=Math.hypot(Pn.x-P.x, Pn.y-P.y);
  path[i+1] = { x: P.x + L*Math.cos(theta), y: P.y + L*Math.sin(theta) };
  draw();
}

document.getElementById('applyCorner').onclick=()=>{
  const i=Math.max(1, Math.min(parseInt(document.getElementById('corner').value||'1'), path.length-2));
  const ang=parseFloat(document.getElementById('cornerAng').value||'90');
  applyCorner(i, ang);
};

function refreshEditor(){
  const S=segs();
  if(!S.length){ document.getElementById('segLen').value=0; document.getElementById('segAng').value=0; return; }
  let i=Math.min(parseInt(document.getElementById('seg').value||'0'), S.length-1);
  const a=S[i][0], b=S[i][1]; const dx=b.x-a.x, dy=b.y-a.y;
  document.getElementById('segLen').value=(Math.hypot(dx,dy)/pxPerMm).toFixed(0);
  // angle for segment: show 0..180 relative to +X
  const baseDeg = (Math.atan2(-dy,dx)*180/Math.PI);
  document.getElementById('segAng').value = ( ((baseDeg%360)+360)%360 > 180 ? 360-(((baseDeg%360)+360)%360) : ((baseDeg%360)+360)%360 ).toFixed(1);
  draw(i);
}
document.getElementById('seg').onchange=refreshEditor;

document.getElementById('apply').onclick=()=>{
  const S=segs(); if(!S.length) return;
  let i=Math.min(parseInt(document.getElementById('seg').value||'0'), S.length-1);
  const a=path[i]; const len=(parseFloat(document.getElementById('segLen').value)||0)*pxPerMm;
  const angDeg=parseFloat(document.getElementById('segAng').value||0);
  const ang=angDeg*Math.PI/180;
  path[i+1]={x:a.x+len*Math.cos(ang),y:a.y-len*Math.sin(ang)}; draw(i);
};

function draw(){
  ctx.clearRect(0,0,cv.width,cv.height);
  if(!path.length) return;

  ctx.save(); ctx.scale(Z,Z);

  // base polyline
  ctx.strokeStyle='#000'; ctx.lineWidth=2/ Z;
  ctx.beginPath(); ctx.moveTo(path[0].x,path[0].y); for(let i=1;i<path.length;i++) ctx.lineTo(path[i].x,path[i].y); ctx.stroke();

  // coloured face
  const face=faceSel.value, hex=colourSel.value;
  ctx.strokeStyle=hex; ctx.lineWidth=6/ Z; ctx.globalAlpha=.35;
  for(let i=0;i<path.length-1;i++){ const a=path[i],b=path[i+1]; const n=normal(a.x,a.y,b.x,b.y); const off=face==='left'?6:-6; ctx.beginPath(); ctx.moveTo(a.x+n.x*off,a.y+n.y*off); ctx.lineTo(b.x+n.x*off,b.y+n.y*off); ctx.stroke(); }
  ctx.globalAlpha=1;

  // points
  ctx.fillStyle='#000'; for(const p of path){ ctx.beginPath(); ctx.arc(p.x,p.y,3/ Z,0,Math.PI*2); ctx.fill(); }

  // corner arcs: always smallest
  const r=20; // model pixels; line width scaled inversely
  ctx.strokeStyle='#555'; ctx.lineWidth=1/ Z; ctx.setLineDash([4/ Z,3/ Z]);
  for(let i=1;i<path.length-1;i++){
    const pm=path[i-1], p=path[i], pn=path[i+1];
    let a1=Math.atan2(pm.y-p.y, pm.x-p.x);
    let a2=Math.atan2(pn.y-p.y, pn.x-p.x);
    // Normalize to draw the smaller arc
    let diff=a2-a1;
    while(diff>Math.PI) { a2-=2*Math.PI; diff=a2-a1; }
    while(diff<-Math.PI){ a2+=2*Math.PI; diff=a2-a1; }
    ctx.beginPath(); ctx.arc(p.x,p.y,r, a1, a2); ctx.stroke();
  }
  ctx.setLineDash([]);
  ctx.restore();

  // labels (screen space; constant size)
  ctx.font='12px system-ui,-apple-system';
  // lengths
  for(let i=0;i<path.length-1;i++){
    const a=path[i],b=path[i+1]; const L=Math.hypot(b.x-a.x,b.y-a.y)/pxPerMm;
    const midx=(a.x+b.x)/2*Z, midy=(a.y+b.y)/2*Z;
    drawBadge(midx, midy, Math.round(L)+' mm');
  }
  // corner angles
  for(let i=1;i<path.length-1;i++){
    const ang=cornerAngle(path[i-1],path[i],path[i+1]).toFixed(1);
    const bx=path[i].x*Z+8, by=path[i].y*Z-8;
    drawBadge(bx, by, ang+'Â°');
  }
}

function drawBadge(cx,cy,text){
  const w=ctx.measureText(text).width+12, h=18;
  ctx.fillStyle='#d00'; roundRect(ctx,cx-w/2, cy-h/2, w, h, 9); ctx.fill();
  ctx.fillStyle='#fff'; ctx.fillText(text, cx - w/2 + 6, cy + 4);
}

function roundRect(ctx,x,y,w,h,r){ctx.beginPath();ctx.moveTo(x+r,y);ctx.arcTo(x+w,y,x+w,y+h,r);ctx.arcTo(x+w,y+h,x,y+h,r);ctx.arcTo(x,y+h,x,y,r);ctx.arcTo(x,y,x+w,y,r);}

draw();
</script>
</body></html>
